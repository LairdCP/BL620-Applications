//******************************************************************************
// Laird Technologies (c) 2014
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++                                                                      ++
// +++++  When UwTerminal downloads the app it will store it as a filenname   ++
// +++++  which consists of all characters up to the first . and excluding it ++
// +++++                                                                      ++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Version 1.0, 25/11/2014
// This application allows you to scan for iBeacons, display the parameters you choose,
// and connect to iBeacons to edit their parameters via the Laird Technologies iBeacon
// service.
//
// This app provides for a command interface over the uart and the protocol is
// as follows:-
//
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Convention : (1) Case sensitive, and commands are presented in alphabetic order
//              (2) If line ends with \ then it continues on next line. That does
//                  not mean that it should be sent as multiple lines
//              (3) Replace anything between ## 
//              (4) #INTaaaa# means a number in decimal, hex, octal or binary
//                      format -> 23 == 0x17 == h'17 == o'23 == b'10111
//                      aaaa is just a description
//              (5) #HEXaaaa# means a string without delimitors consisting of hex 
//                      characters only aaaa is just a description
//              (6) #STRaaaa# means a string without delimitors
//                      aaaa is just a description
//              (7) "STRaaaa" means a string which must have the " delimitor
//                      aaaa is just a description
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// -----------------------------------------------------------------------------
// scan
//   - Starts scanning for iBeacons 
//
// -----------------------------------------------------------------------------
// stop
//   - Stops scanning for iBeacons
//
// -----------------------------------------------------------------------------
// quit OR exit
//   - Exits the application and returns to command mode
//
// -----------------------------------------------------------------------------
// config scan display #Options#
//   - Configure what iBeacon data will be displayed with advert report data.
//   * Note: The iBeacon's device name, BT address and RSSI will always be shown *
//
//   #Options#
//     -uuid    :   Display iBeacon UUID
//     -major   :   Display iBeacon Major value
//     -minor   :   Display iBeacon Minor value
//     -tx      :   Display iBeacon UUID
//     -all     :   Display all iBeacon data (all of the above)
//     -none    :   Display no iBeacon data - just the device name, BT address and RSSI
//     -other   :   Display any other AD tags
//
//   Examples: 
//     Show the UUID and TX power:      "config display -uuid -tx"
//     Show the Major and Minor values: "config display -major -minor"
//     
// -----------------------------------------------------------------------------
// config scan timeout #INTtimeoutsec#
//   - Sets the scan timeout (in seconds). After scanning for this time
//     the scan will automatically stop. Set to 0 for infinite scanning
//
// -----------------------------------------------------------------------------
// config scan interval #INTscanintvl#
//   - Sets the Scan Interval in milliseconds (range 0..10240)
//
// -----------------------------------------------------------------------------
// config scan window #INTscanwindow#
//   - Sets the Scan Window in milliseconds (range 0..10240)
//
// -----------------------------------------------------------------------------
// config scan showduplicates #INTshowduplicates#
//   - If set to 1, all advert reports received from iBeacons will be displayed.
//   - If set to 0, only 1 advert report will be displayed for any 1 iBeacon.
//
// -----------------------------------------------------------------------------
// config scan numdevices #INTdevicestoshow#
//   - Sets the maximum number of devices to detect when scanning. If this limit
//     is reached then scanning with automatically stop. 
//
//   * This only applies if 'showduplicates' is set to 0
//
// -----------------------------------------------------------------------------
// config txpower #INTtxpower#
//   - Sets transmit power of the module in dBm (valid values: 4, 0, -4, -8, 
//     -12, -16, -20, -30 and -55).
//
// -----------------------------------------------------------------------------
// connect #HEX7bytesbdAddr# 
//    - connect to iBeacon with given BT address
//
// -----------------------------------------------------------------------------
// disconnect
//    - disconnect from the iBeacon
//
// -----------------------------------------------------------------------------

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// iBeacon Configuration Commands
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// -----------------------------------------------------------------------------
// devname ? 
//   - Returns the iBeacon's Device Name
//
// -----------------------------------------------------------------------------
// devname = #STRdevname# 
//   - Sets a new device name for the iBeacon
//
//   ~ Example: "devname = My iBeacon" sets the Device Name to "My iBeacon"
//
// -----------------------------------------------------------------------------
// uuid ? 
//   - Returns the iBeacon UUID
//
// -----------------------------------------------------------------------------
// uuid = #STRiBeaconUUID#
//   - Sets a new iBeacon UUID
//   - Length: 16 bytes 
//
//   ~ Example: "uuid = 598d54a22f4245f99398bbe45f68adfc" 
//              sets uuid to 598d54a22f4245f99398bbe45f68adfc
//
// -----------------------------------------------------------------------------
// major ?
//   - Returns the iBeacon Major value
//
// -----------------------------------------------------------------------------
// major = #HEXmajor#
//   - Sets a new iBeacon Major value
//   - Length: 2 bytes  
//
//   ~ Example: "major = 1234" sets minor to 1234
//
// -----------------------------------------------------------------------------
// minor ?
//   - Returns the iBeacon Minor value
//
// -----------------------------------------------------------------------------
// minor = #HEXminor#
//   - Sets a new iBeacon Minor value
//   - Length: 2 bytes 
//
//   ~ Example: "minor = 5678" sets minor to 5678
//
// -----------------------------------------------------------------------------
// txpower ?
//   - Returns the iBeacon Transmitting Power
//
// -----------------------------------------------------------------------------
// txpower = #INTtxPower#
//   - Sets a new iBeacon Transmitting Power
//   - Valid values: -55, -30, -20, -16, -12, -8, -4, 0, 4, 8 ->(BT900 only)
//   - Unit:  dBm
//
//   ~ Example: "txpower = -8" sets tx power to -8 dBm
//
// -----------------------------------------------------------------------------
// adinterval ?
//   - Returns the iBeacon Advertising Interval
//
// -----------------------------------------------------------------------------
// adinterval = #INTadInterval#
//   - Sets a new iBeacon Advertising Interval
//   - Length: 1 byte (unsigned 8 bit)
//   - Unit:  20 ms (e.g. 50 will give 1000ms)
//   - Note: Advertising Interval shall be no lower than 100 ms
//
//   ~ Example: "adinterval = 10" sets advertising interval to 200 ms
//
// -----------------------------------------------------------------------------
// adtimeout ?
//   - Returns the iBeacon Advertising Time out
//
// -----------------------------------------------------------------------------
// adtimeout = #INTadtimeout#
//   - Sets a new iBeacon Advertising Interval
//   - Length: 1 byte (unsigned 8 bit)
//   - Unit:  minutes (e.g. 10 will give 600000ms), 0 == forever 
//
//   ~ Example: "adtimeout = 5" sets advertising timeout to 5 minutes
//
// -----------------------------------------------------------------------------
// calrssi ?
//   - Returns the RSSI measured 1m from BL600 when Tx Power = 4 dBm  
//
// -----------------------------------------------------------------------------
// calrssi = #INTcalrssi#
//   - Sets a new Calibrated RSSI Value (RSSI at 100m distance from iBeacon)
//   - Length: 1 byte (signed 8 bit)
//   - Unit:  dBm
//
//   ~ Example: "calrssi = -60" sets calibrated rssi to -60 dBm
//
// -----------------------------------------------------------------------------
// timeconnectable ?
//   - Returns the time for which the module will accept connections
//   - Length: 1 byte (unsigned 8 bit)
//   - Unit: seconds  
//
// -----------------------------------------------------------------------------
// timeconnectable = #timeconnectable#
//   - Sets a new time for which the module will accept connections
//   - Length: 1 byte (unsigned 8 bit)
//   - Unit: seconds
//   - Valid values: 1-255
//
//   ~ Example: "timeconnectable = 60" sets advertising timeout to 60 seconds
// -----------------------------------------------------------------------------


//******************************************************************************
// Definitions
//******************************************************************************
        //Default Scan Interval ms
#define SCAN_INTERVAL_DEF                    80  
        //Default Scan Window ms
#define SCAN_WINDOW_DEF                      40
        //Default Scan Type ms
#define SCAN_TYPE_DEF                        40 

        //Connection timeout ms
#define CONN_TMT                            10000
        //Min Connection interval us
#define MIN_CONN_INTVL                      7500
        //Max Connection interval us
#define MAX_CONN_INTVL                      40000
        //Link supervision timeout us
#define LINK_SUP_TMT                        3000000
        //Scan timeout ms
#define SCAN_TMT                            10000       


        //Set this to 0 to disable all debugging messages
#define ENABLE_DEBUG_PRINTS                  1
        // Max Number of connections
#define NUM_OF_CONNS                         1
        // size of i[]
#define NUM_OF_I_PARAMS                     (8)
        // size of s$[] and must be at least 8 elements for BleSvcRegDevInfo()     
#define NUM_OF_S_PARAMS                     (8)


        '// Laird Technologies 128 bit Base UUID
#define LT_BASE_UUID                        "\56\9a\00\00\b8\7f\49\0c\92\cb\11\ba\5e\a5\16\7c\"
        '// iBeacon Service 16 bit UUID
#define IBEACON_SVC_UUID                    0x1900
        '// iBeacon Service Device Name char UUID
#define IBEACON_DEVNAME_CHAR_UUID           0x2010
        '// iBeacon Service UUID char UUID
#define IBEACON_UUID_CHAR_UUID              0x2012
        '// iBeacon Service Major char UUID
#define IBEACON_MAJOR_CHAR_UUID             0x2013
        '// iBeacon Service Minor char UUID
#define IBEACON_MINOR_CHAR_UUID             0x2014
        '// Bluetooth Adopted TX char UUID
#define TX_CHAR_UUID                        0x2A07
        '// iBeacon Service Advertising Interval char UUID
#define IBEACON_ADINT_CHAR_UUID             0x2015
        '// iBeacon Service Advertising Timeout char UUID
#define IBEACON_ADTO_CHAR_UUID              0x2016
        '// iBeacon Service Calibrated RSSI Value char UUID
#define IBEACON_CALRSSI_CHAR_UUID           0x2017
        '// iBeacon Service Remain Connectible Time Value char UUID
#define IBEACON_REMCONNTIME_CHAR_UUID       0x2018


        '// Array index for device name
#define DVC_NME_INDEX                        0
        '// Array index for format
#define FORMAT_INDEX                         1
        '// Array index for UUID value 
#define UUID_INDEX                           2
        '// Array index for Major value
#define MAJOR_INDEX                          3
        '// Array index for Minor value
#define MINOR_INDEX                          4
        '// Array index for TxPower value
#define TXPOWER_INDEX                        5
        '// Array index for Interval (supplied in 20ms units)
#define ADV_INTVL_INDEX                      6
        '//Array index for Time out (supplied as minutes)
#define ADV_TMT_INDEX                        7 
        '//Array index for Calibrated RSSI Value 
#define CAL_RSSI_INDEX                       8
        '// Array index for Remain Connectible Time (supplied in seconds)
#define REM_CONN_TME_INDEX                   9


//BLE EVENT MSG IDs
#define BLE_EVBLEMSGID_CONNECT                          0 // msgCtx = connection handle
#define BLE_EVBLEMSGID_DISCONNECT                       1 // msgCtx = connection handle

        '//Number of characteristics 
#define NUM_OF_CHARS                         10


//******************************************************************************
// Global Variable Declarations
//******************************************************************************

dim rc
dim stRsp$ as string          //Uart rx data is stored here

dim ok$,er$,pr$,nc$

dim i[NUM_OF_I_PARAMS]        //index 0 used for return values
dim s$[NUM_OF_S_PARAMS]       //must be at least 8 elements for BleSvcRegDevInfo()

dim urtcmd$                   //cmd line from uart
dim tkn$,tlen                 //used by command parser
dim hc[NUM_OF_CONNS+1]        //contains connection handles
dim numConns                     //number of connections
dim urts                      //will be <0 if uart parser suspended
dim carCnt                    //count variable for number of times '^' entered
dim ScanTimeout               //When a scan will timeout (seconds)
dim ScanDuplicates            //Set to 1 to show duplicate devices
dim ScanDevices               //Maximum number of devices to discover
dim ScanTable$                //Table containing IDs of devices
dim ScanDeviceCount           //Number of devices found on this scan

dim hIBSvcUUID               //handle of LT iBeacon Service UUID
dim hChars[NUM_OF_CHARS]     '//array of characteristic value attribute handles
                               // 0 : Device Name
                               // 1 : Format (Not used)
                               // 2 : iBeacon UUID 
                               // 3 : iBeacon Major 
                               // 4 : iBeacon Minor 
                               // 5 : iBeacon TxPower (Adopted Char from Bluetooth SIG)
                               // 6 : Advertising Interval
                               // 7 : Advert Time out
                               // 8 : Calibrated RSSI Value
                               // 9 : Remain Connectible Time
                             '//---------------------------------------
                             
dim hCharUUIDs[NUM_OF_CHARS]  //array of characteristic UUIDs - indexes same as above

dim tbDispParams$             //table of specified display parameters for iBeacon advert reports
                              //see 'config scan display'
dim tbDisParIDs               //ID count for scan display parameters table

dim charIndex                 //index of current characteristic being found/processed

dim ltBseUuid$                //LT Base UUID
dim hBseUuid                  //handle if the LT Base UUID
                              

//******************************************************************************
// Initialisse Global Variable
//******************************************************************************
//TODO: make hChars = 0 on disconnection
ok$    = "\nOK"
er$    = "\nERROR "
pr$    = "\r\n>"
nc$    = "\nNot Connected"

urts = 0            //not suspended
numConns = 0           //number of connections
ScanTimeout = 10    //Default scan time of 10 seconds
ScanDuplicates = 0  //Do not show duplicates
ScanDevices = 0     //Unlimited number of devices
ScanDeviceCount = 0 //No devices found yet

ltBseUuid$ = LT_BASE_UUID
hBseUuid = BleHandleUuid128(ltBseUuid$)

//Get handles for the relevant UUIDs
hIBSvcUUID = BleHandleUuidSibling(hBseUuid, IBEACON_SVC_UUID)
hCharUUIDs[DVC_NME_INDEX] = BleHandleUuidSibling(hBseUuid, IBEACON_DEVNAME_CHAR_UUID)
hCharUUIDs[UUID_INDEX] = BleHandleUuidSibling(hBseUuid, IBEACON_UUID_CHAR_UUID)
hCharUUIDs[MAJOR_INDEX] = BleHandleUuidSibling(hBseUuid, IBEACON_MAJOR_CHAR_UUID)
hCharUUIDs[MINOR_INDEX] = BleHandleUuidSibling(hBseUuid, IBEACON_MINOR_CHAR_UUID)
hCharUUIDs[TXPOWER_INDEX] = BleHandleUuid16(TX_CHAR_UUID)
hCharUUIDs[ADV_INTVL_INDEX] = BleHandleUuidSibling(hBseUuid, IBEACON_ADINT_CHAR_UUID)
hCharUUIDs[ADV_TMT_INDEX] = BleHandleUuidSibling(hBseUuid, IBEACON_ADTO_CHAR_UUID)
hCharUUIDs[CAL_RSSI_INDEX] = BleHandleUuidSibling(hBseUuid, IBEACON_CALRSSI_CHAR_UUID)
hCharUUIDs[REM_CONN_TME_INDEX] = BleHandleUuidSibling(hBseUuid, IBEACON_REMCONNTIME_CHAR_UUID)



//******************************************************************************
// Register Error Handler as early as possible
//******************************************************************************
sub HandlerOnErr()
  if (ENABLE_DEBUG_PRINTS!=0) then
    print "\n OnErr - ";GetLastError();"\n"
  endif
endsub
onerror next HandlerOnErr

//******************************************************************************
// Debugging resource as early as possible
//******************************************************************************

//==============================================================================
//==============================================================================
sub AssertResCode(byval rc as integer,byval tag as integer)
  if (ENABLE_DEBUG_PRINTS!=0) && (rc!=0) then
    print "\nFailed with ";integer.h' rc;" at tag ";tag
  endif
endsub

//==============================================================================
//==============================================================================
sub DbgMsg(byval msg$ as string)
  if (ENABLE_DEBUG_PRINTS!=0) then
    print "\n";msg$
  endif
endsub

//==============================================================================
//==============================================================================
sub DbgMsgVal(byval msg$ as string, byval vl as integer)
  if (ENABLE_DEBUG_PRINTS!=0) then
    print "\n";msg$;" ";vl
  endif
endsub

//==============================================================================
//==============================================================================
sub UartRsp(rsp as integer)
    if rsp == 0 then
        print ok$;pr$
    elseif rsp == -2 then
        print pr$
    elseif rsp == -3 then
        print nc$;pr$
    elseif rsp > 0 then 
        print er$;integer.h' rsp;pr$
    endif
endsub

//-------------------------------------------------------------------------
//-------------------------------------------------------------------------
function ExtractIntTokens(u$,stIdx,num)
  while num>0
    tlen = ExtractIntToken(u$,i[stIdx])
    if tlen == 0 then
      exitfunc 4
    endif
    num=num-1
    stIdx = stIdx+1
  endwhile
endfunc 0

//-------------------------------------------------------------------------
//-------------------------------------------------------------------------
function ExtractStrTokens(u$,stIdx,num)
  while num>0
    tlen = ExtractStrToken(u$,s$[stIdx])
    if tlen == 0 then
      exitfunc 3
    endif
    num=num-1
    stIdx = stIdx+1
  endwhile
endfunc 0





'//******************************************************************************
'// Function and Subroutine definitions
'//******************************************************************************
'//------------------------------------------------------------------------------
'// Swap the order of the 2 lower bytes of the argument
'//------------------------------------------------------------------------------
Function SwapBytes(v)
Endfunc ((v>>8)&0xFF) + ((v<<8)&0xFF00)


'//------------------------------------------------------------------------------
'// Get index of the given handle in the 'hChars[]' array
'//------------------------------------------------------------------------------
Function GetCharIndex(ByVal cHndl)
   dim i
    for i=0 to NUM_OF_CHARS-1 
        if hChars[i]==cHndl then
            ExitFunc i                 //return the index of given handle 
        endif
    next    
EndFunc -1                             //at this point, whole array has been searched.
 
 
'//------------------------------------------------------------------------------
'// Extract the iBeacon elements from the advert report 
'// -- Uses the parameters given in 'config scan display'
'//------------------------------------------------------------------------------
Sub PrintiBeaconParams(iBeaconDta$)
    dim rc, uuid$, tok$, major, minor, tx
    
    //strip off first 4 bytes (company ID, datatype, length)
    StrShiftLeft(iBeaconDta$, 4)
    
    '//get the uuid
    uuid$ = StrSplitLeft$(iBeaconDta$,16)
    uuid$ = StrHexize$(uuid$)
    
    '//get the major value
    rc=BleDecodeU16(iBeaconDta$, major, 0)
    major = SwapBytes(major)
    StrShiftLeft(iBeaconDta$,2)
    
    '//get the minor value
    rc=BleDecodeU16(iBeaconDta$, minor, 0)
    minor = SwapBytes(minor)
    StrShiftLeft(iBeaconDta$,2)
    
    '//get the tx power
    rc=BleDecodeS8(iBeaconDta$, tx, 0)
    
    '//print no iBeacon parameters
    tok$ = "none"
    if TableLookup(tbDispParams$,tok$)>=0 then      
        exitsub
    endif
    
    '//print all iBeacon parameters
    tok$ = "all"
    if TableLookup(tbDispParams$,tok$)>=0 then
        print "\n   (UUID)     ";uuid$
        print "\n   (Major)    ";major
        print "\n   (Minor)    ";minor
        print "\n   (1m RSSI)  ";tx
        
        exitsub
    endif  
    
    '//print the iBeacon UUID
    tok$ = "uuid"
    if TableLookup(tbDispParams$,tok$)>=0 then
        print "\n   (UUID)     ";uuid$
    endif
    
    '//print the iBeacon major val
    tok$ = "major"
    if TableLookup(tbDispParams$,tok$)>=0 then
        print "\n   (Major)    ";major
    endif
    
    '//print the iBeacon minor val
    tok$ = "minor"
    if TableLookup(tbDispParams$,tok$)>=0 then
        print "\n   (Minor)    ";minor
    endif
    
    '//print the iBeacon tx power
    tok$ = "tx"
    if TableLookup(tbDispParams$,tok$)>=0 then
        print "\n   (1m RSSI)  ";tx
    endif
EndSub
    

//-------------------------------------------------------------------------
//#CMD#//  config scan timeout #INTtimeoutsec#
//#CMD#//  config scan interval #INTscanintvl#
//#CMD#//  config scan window #INTscanwindow#
//#CMD#//  config scan display #options#
//#CMD#//  config scan numdevices #INTnumdevices#
//#CMD#//  config scan showduplicates #INTshowduplicates#
//-------------------------------------------------------------------------
function _configScan()
    tlen = ExtractStrToken(urtcmd$,tkn$)
    if tlen == 0 then
        exitfunc 5
    endif
    
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"timeout")==0 then
        //extract 1 (#INTmode#) and store starting at i[1]
        rc = ExtractIntTokens(urtcmd$,1,1)
        
        if rc != 0 then
            exitfunc rc
        endif
        
        ScanTimeout = i[1]
        exitfunc 0
        
        
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    elseif strcmp(tkn$,"interval")==0 then
        //extract 1 (#INTmode#) and store starting at i[1]
        rc = ExtractIntTokens(urtcmd$,1,1)
        if rc != 0 then
            exitfunc rc
        endif
        
        exitfunc BleScanConfig(0,i[1])
        
        
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    elseif strcmp(tkn$,"window")==0 then
        //extract 1 (#INTmode#) and store starting at i[1]
        rc = ExtractIntTokens(urtcmd$,1,1)
        if rc != 0 then
            exitfunc rc
        endif
        
        exitfunc BleScanConfig(1,i[1])
    
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    elseif strcmp(tkn$,"display")==0 then
        tbDispParams$=""
        if TableInit(tbDispParams$)!=0 then
            exitfunc rc
        endif
        
        while ExtractStrToken(urtcmd$,tkn$)!=0
            '//add each parameter to the table
            if strcmp(tkn$,"-")!=0 then           
                tbDisParIDs = tbDisParIDs+1
                
                if TableAdd(tbDispParams$,tkn$,tbDisParIDs)!=0 then
                    tbDisParIDs = tbDisParIDs - 1
                    exitfunc rc
                endif
            endif
        endwhile 
        
        exitfunc 0
        
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    elseif strcmp(tkn$,"numdevices")==0 then
        //extract 1 (#INTdevicestoshow#) and store starting at i[1]
        rc = ExtractIntTokens(urtcmd$,1,1)
        if rc != 0 then
          exitfunc rc
        endif
        ScanDevices = i[1]
        exitfunc 0
        
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    elseif strcmp(tkn$,"showduplicates")==0 then
        //extract 1 (#INTshowduplicates#) and store starting at i[1]
        rc = ExtractIntTokens(urtcmd$,1,1)
        if rc != 0 then
            exitfunc rc
        endif
      
        if (i[1] == 0 || i[1] == 1) then
            //Valid
            ScanDuplicates = i[1]
            exitfunc 0
        endif
        
    endif
endfunc 5


//-------------------------------------------------------------------------
// Start scanning for iBeacons
//-------------------------------------------------------------------------
function _scan() 
    rc=BleScanStop()
    rc = TableInit(ScanTable$) //Create lookup table
    AssertResCode(rc, 333)
    ScanDeviceCount = 0
    rc = BleScanStart(ScanTimeout*1000, 0)
    if rc!=0 then
        exitfunc rc
    endif
endfunc -1   //don't give response to the user until scan stops

    
//-------------------------------------------------------------------------
// Connect to either specified or default device
//-------------------------------------------------------------------------
function _connect() 
    if numConns == NUM_OF_CONNS then
        print "\nAlready Connected"
        exitfunc -2
    endif
    
    '//Stop scanning before connecting
    rc=BleScanStop()  
    
    '//only opening gatt client when we need it to save memory
    rc=BleGattcOpen(0,0)
    AssertResCode(rc,452)
 
    rc=ExtractStrTokens(urtcmd$,1,1)
    '//use #defined/stored mac address if none given
    if rc!=0 then
        exitfunc 5
    endif
    
    s$[1] = StrDehexize$(s$[1])

    rc=BleConnect(s$[1], CONN_TMT, MIN_CONN_INTVL, MAX_CONN_INTVL, LINK_SUP_TMT)
    if rc!=0 then
        exitfunc rc
    endif  
endfunc -1


//-------------------------------------------------------------------------
// Disconnect
//-------------------------------------------------------------------------
function _disconnect() 
    rc = BleDisconnect(hc[0])
endfunc -1  //dont give response to user


//-------------------------------------------------------------------------
// iBeacon config - write or read characteristic
//-------------------------------------------------------------------------
function _iBeaconConfig(chrInd) 
    if numConns == 0 then
        exitfunc -3     //print not connected response
    endif
    
    //get '?' or '='
    dim tkn
    tlen = ExtractStrToken(urtcmd$,tkn$)
    if tlen == 0 then
        exitfunc 5
    endif
    
    
    '//if reading the value of a characteristic
    if strcmp(tkn$,"?")==0 then 
        rc=BleGattcRead(hc[0],hChars[chrInd],0)
        AssertResCode(rc,671)
        
    '//if writing a new value to a characteristic
    elseif strcmp(tkn$,"=")==0 then
        if chrInd == (DVC_NME_INDEX) || chrInd == (UUID_INDEX) then   
            '//remove leading spaces
            while StrGetChr(urtcmd$,0)==0x20
                StrShiftLeft(urtcmd$,1)
            endwhile
            
            '//remove carriage return
            dim s$ : s$ = Right$(urtcmd$,1)
            if StrGetChr(s$,0)==0x0D then
                urtcmd$ = StrSplitLeft$(urtcmd$,(StrLen(urtcmd$)-1))
            endif
            
            if chrInd == (UUID_INDEX) then            
                urtcmd$ = StrDehexize$(urtcmd$)
            endif
            tkn$ = urtcmd$
            
        
        elseif chrInd == (MAJOR_INDEX) || chrInd == (MINOR_INDEX) then  
            tlen = ExtractStrToken(urtcmd$,tkn$)
            tkn$ = StrDehexize$(tkn$)
        else    
            tlen = ExtractIntToken(urtcmd$,tkn)
            rc= BleEncode8(tkn$, tkn, 0)
        endif
        
        '//write new value to characteristic
        rc=BleGattcWrite(hc[0], hChars[chrInd], tkn$)
        if rc!=0 then   
            exitfunc rc
        endif
        tkn$=""
    else    
        exitfunc 5
    endif      
endfunc -1
    
    

//-------------------------------------------------------------------------
//#CMD#//  config scan ...
//#CMD#//  config txpower #INTtxpower#
//-------------------------------------------------------------------------
function _Config()
    tlen = ExtractStrToken(urtcmd$,tkn$)
    if tlen == 0 then
        exitfunc 5
    endif

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"scan")==0 then
        exitfunc _configScan()

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    elseif strcmp(tkn$,"txpower")==0 then
        //extract 1 (#INTtxpower#) and store starting at i[1]
        rc = ExtractIntTokens(urtcmd$,1,1)
        exitfunc BLETXPOWERSET(i[1])
        
    endif
endfunc 5


//-------------------------------------------------------------------------
//#CMD#//  scan
//#CMD#//  stop
//#CMD#//  exit
//#CMD#//  quit
//#CMD#//  config ...
//#CMD#//  connect
//#CMD#//  disconnect
//#CMD#//  devname?=
//#CMD#//  uuid?=
//#CMD#//  major?=
//#CMD#//  minor?=
//#CMD#//  txpower?=
//#CMD#//  adinterval?=
//#CMD#//  adtimeout?=
//#CMD#//  calrssi?=
//#CMD#//  timeconnectable?=
//-------------------------------------------------------------------------
function OnUartCmd() as integer
  rc=-2 //default response is ">"
  tlen = ExtractStrToken(urtcmd$,tkn$) //get first token
  if tlen > 0 then

        if strcmp(tkn$,"stop")==0 then
            //Stop scanning for iBeacons
            rc = BleScanStop()

        elseif strcmp(tkn$,"scan")==0 then
            //Start scanning for iBeacons          
            rc = _scan()
            
        elseif strcmp(tkn$,"config")==0 then
            //Change configuration
            rc = _Config()

        elseif strcmp(tkn$,"connect")==0 then
            rc = _connect()

        elseif strcmp(tkn$,"disconnect")==0 then
            rc = _disconnect()

        elseif strcmp(tkn$,"exit")==0 || strcmp(tkn$,"quit")==0  then
            //Stop scanning for iBeacons
            rc = BleScanStop()
            exitfunc 0
            
        '//These are the iBeacon config commands   
        elseif strcmp(tkn$,"devname")==0 then
            rc=_iBeaconConfig(DVC_NME_INDEX)
            
        elseif strcmp(tkn$,"uuid")==0 then
            rc=_iBeaconConfig(UUID_INDEX)
            
        elseif strcmp(tkn$,"major")==0 then 
            rc=_iBeaconConfig(MAJOR_INDEX)
        
        elseif strcmp(tkn$,"minor")==0 then 
            rc=_iBeaconConfig(MINOR_INDEX)
        
        elseif strcmp(tkn$,"txpower")==0 then 
            rc=_iBeaconConfig(TXPOWER_INDEX)
        
        elseif strcmp(tkn$,"adinterval")==0 then 
            rc=_iBeaconConfig(ADV_INTVL_INDEX)
            
        elseif strcmp(tkn$,"adtimeout")==0 then 
            rc=_iBeaconConfig(ADV_TMT_INDEX)
            
        elseif strcmp(tkn$,"calrssi")==0 then 
            rc=_iBeaconConfig(CAL_RSSI_INDEX)
           
        elseif strcmp(tkn$,"timeconnectable")==0 then 
            rc=_iBeaconConfig(REM_CONN_TME_INDEX)

        endif
  endif
  // send a response back to the user
  UartRsp(rc)
endfunc 1


'//******************************************************************************
'// Handler definitions
'//******************************************************************************
//------------------------------------------------------------------------------
// This handler is called when there is an advert report waiting to be read
//------------------------------------------------------------------------------
function HandlerAdvRpt() as integer
    '//--- iBeacon Advert Report Format:                                              
    '// 0 1  2  3  4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9  0 1  2 3  4
    '// CompanyID
    '//      DataType
    '//         Length
    '//            UUID
    '//                                             0 1  2 3  4
    '//                                             Major
    '//                                                  Minor
    '//                                                       TxPower
    '// 4C00 02 15 E2C56DB5DFFB48D2B060D0F5A71096E0 0000 0000 C5
    '// ---
    
    dim ad$,dta$,ndisc,rsi,nme$
    
    while BleScanGetAdvReport(ad$,dta$,ndisc,rsi)==0
        dim uuid$, major, minor, txpower, iBdta$
        
        '//this tells us whether advert report came from an iBeacon
        if StrGetChr(dta$,7)==0x02 && StrGetChr(dta$,8)==0x15 then
        
            '//if not displaying duplicate scan report from the same device
            if ScanDuplicates == 0 then
                //if device isn't in the table
                if TableLookup(ScanTable$,ad$)<0 then
                    rc=TableAdd(ScanTable$, ad$, ScanDeviceCount)
                    ScanDeviceCount = ScanDeviceCount + 1
                else
                    break
                endif
            endif
            
            '//get name of device
            rc=BleGetADByTag(dta$,0x09,nme$)
            
            //Get AD element with iBeacon data
            rc=BleGetADByTag(dta$,0xFF,iBdta$)

            
            
            '//print <Device Name> : <MAC Address> : <RSSI> - seperated by tabs
             //        (UUID)    :   <UUID>
             //        (Major)   :   <Major>
             //        (Minjor)  :   <Minor>
             //        (TxPower) :   <TxPower>
            print "\n";StrHexize$(ad$);"  : ";rsi;" :  ";nme$
            PrintiBeaconParams(iBdta$)

            '//for printing other AD elements    
            dim i, s$, tok$
        
            tok$ = "other"
            if TableLookup(tbDispParams$,tok$)>=0 then
                print "\n Other ADs: "
                
                for i=0x01 to 0xFE
                    if i==0x09 then
                    else
                        rc=BleGetAdByTag(dta$,i,s$)
                        if StrLen(s$)!=0 then
                            dim d$
                            sprint #d$,integer.h'i                            
                            print "\n   Tag 0x" + RIGHT$(d$,2) +": "; s$; "  Hex: "; StrHexize$(s$)    
                        endif
                    endif
                next
                print "\n"
            endif
            
            print "\n"
                
            '//check if max number devices have been found - when not showing duplicate reports
            if ScanDuplicates == 0 then   
                '//if specified max number of devices have been found
                if ScanDeviceCount == ScanDevices then
                    rc=BleScanStop()
                    ScanTable$=""
                    UartRsp(0)
                    print "\n";pr$
                    break       
                endif    
            endif
            
        endif
   
    endwhile
endfunc 1


//------------------------------------------------------------------------------
// This handler is called when there is a BLE message
//------------------------------------------------------------------------------
function HandlerBleMsg(BYVAL nMsgId AS INTEGER, BYVAL nCtx AS INTEGER) as integer
    hc[0] = nCtx
  
    select nMsgId  
        case BLE_EVBLEMSGID_CONNECT
            numConns = numConns + 1
            print "\n\nCONNECT"
            
            // get handle of the device name characteristic
            charIndex = DVC_NME_INDEX
            rc=BleGattcFindChar(hc[0], hIBSvcUUID , 0, hCharUUIDs[DVC_NME_INDEX], 0)
            if rc==0 then
                print "\nSearching for iBeacon Characteristics"
            endif               
            AssertResCode(rc,964)

        case BLE_EVBLEMSGID_DISCONNECT
            print "\nDISCONNECTED";pr$
            
            numConns = numConns - 1
            if numConns < 0 then
                numConns = 0
            endif
            
            BleGattcClose()
            hc[0] = 0
         
        case else      
    endselect    
endfunc 1


//------------------------------------------------------------------------------
// Called after searching for a specific characteristic
//------------------------------------------------------------------------------
function HandlerFindChar(hConn, chProps, hCharVal, hIncSvc)   
    if hCharVal == 0 then
        print "\niBeacon Service not found. Disconnecting..."
        exitfunc 1  
    endif        
   
    '//First characteristic - device name. We want to skip over the Format char
    if charIndex == DVC_NME_INDEX then
        hChars[DVC_NME_INDEX] = hCharVal
        charIndex = UUID_INDEX          //next char to find is iBeacon UUID char
    
    '//otherwise find the next char in the array  
    else
        hChars[charIndex] = hCharVal
        charIndex = charIndex + 1       //set next char to find
        
        '//all chars have been found if current index is NUM_OF_CHARS 
        if charIndex == NUM_OF_CHARS then
            print "\nDone\n"
            UartRsp(-2)
            exitfunc 1
        endif
    endif
    
    print "."
    
    //find the next characteristic
    rc=BleGattcFindChar(hc[0], hIBSvcUUID , 0, hCharUUIDs[charIndex], 0)
    AssertResCode(rc,1011)
endfunc 1


//------------------------------------------------------------------------------
// Called after reading a characteristic's value attribute
//------------------------------------------------------------------------------
function HandlerAttrRead(hConn, hAttr, nSts)   
    dim s$, i
    if nSts==0 then    
        rc=BleGattcReadData(hConn, hAttr, i, s$)
        AssertResCode(rc,1173)
           
        if hAttr == hChars[TXPOWER_INDEX] || hAttr == hChars[CAL_RSSI_INDEX] then    
            rc=BleDecodeS8(s$,i,0)
            print i;" dBm\n";pr$
            exitfunc 1
            
        elseif hAttr == hChars[ADV_INTVL_INDEX] || hAttr == hChars[ADV_TMT_INDEX] || hAttr == hChars[REM_CONN_TME_INDEX] then
            print StrGetChr(s$,0)
            
            i = GetCharIndex(hAttr)
            select i
                case ADV_INTVL_INDEX
                    print " (";StrGetChr(s$,0);"x20 = ";StrGetChr(s$,0) * 20;"ms)"
                case ADV_TMT_INDEX
                    print " minutes"
                case REM_CONN_TME_INDEX
                    print " seconds"
                case else
            endselect
         
            print "\n";pr$ 
            exitfunc 1
            
        elseif hAttr != hChars[DVC_NME_INDEX] then
            s$=StrHexize$(s$)           
        endif
        
        print s$;"\n";pr$

    else    
        print "\nErr: ";integer.h'nSts
    endif
endfunc 1


//------------------------------------------------------------------------------
// Called after searching for a specific characteristic
//------------------------------------------------------------------------------
function HandlerAttrWrite(hConn, hAttr, nSts) 
    UartRsp(nSts)
endfunc -1
    
    
//------------------------------------------------------------------------------
// This handler is called when there is a scan attempt timeout
//------------------------------------------------------------------------------
function HandlerBleScanTO() as integer
    //erase the table where the mac addresses are being stored
    ScanTable$=""
    UartRsp(0)
    
    '//force release heap memory used by scan
    rc=BleScanStart(10,0)
    rc=BleScanStop()
endfunc 1


//------------------------------------------------------------------------------
// This handler is called when there is a connection attempt timeout
//------------------------------------------------------------------------------
function HandlerBleConnTO() as integer
    print"\nConnection attempt stopped via timeout";pr$
endfunc 1


//==============================================================================
// This handler is called when data has arrived at the serial port
//==============================================================================
function HandlerUartRxCmd() as integer
  dim nMatch
  
  if urts < 0 then
    //uart parser is suspended
    exitfunc 1
  endif

  //check if CR has been received
  nMatch=UartReadMatch(stRsp$,13)
  if nMatch!=0 then
    //CR exists in the input buffer
    urtcmd$ = strsplitleft$(stRsp$,nMatch)
    exitfunc OnUartCmd()
  endif
endfunc 1


//Startup
print "\n\r";BleGetDeviceName$();"\n\r"
//Send an OK response
UartRsp(0)

OnEvent  EVUARTRX                 call HandlerUartRxCmd
OnEvent  EVBLE_SCAN_TIMEOUT       call HandlerBleScanTO
OnEvent  EVBLE_ADV_REPORT         call HandlerAdvRpt
OnEvent  EVBLEMSG                 call HandlerBleMsg
OnEvent  EVFINDCHAR               call HandlerFindChar
OnEvent  EVATTRREAD               call HandlerAttrRead
OnEvent  EVATTRWRITE              call HandlerAttrWrite
OnEvent  EVBLE_CONN_TIMEOUT       call HandlerBleConnTO

WAITEVENT
